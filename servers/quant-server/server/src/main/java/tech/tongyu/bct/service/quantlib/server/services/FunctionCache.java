package tech.tongyu.bct.service.quantlib.server.services;

import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public enum FunctionCache {
    Instance;

    public static class FuncParam {
        public String name;
        public String type;
        public String description;
        public boolean required = true;
    }

    public static class FuncDescription {
        public Method func;
        public String method;
        public String description;
        public FuncParam[] args;
        public String retName;
        public String retType;
        public String retDescription;
        // only used for Excel where a user provided id can be provided
        // the id will be used to store an object in the object cache
        public boolean addIdInput;
    }

    static private final Cache<String, FuncDescription> cache = CacheBuilder.newBuilder().build();

    public void register(FuncDescription func) {
        String k = func.method;
        cache.put(k, func);
    }

    public Object invoke(String func, Map<String, Object> args) throws Exception {
        FuncDescription description = cache.getIfPresent(func);
        if (description == null)
            throw new Exception(func + " is not a registered API function");
        if (description.args == null || description.args.length == 0)
            return description.func.invoke(null, (Object[]) null);
        Object[] funcArgs = new Object[description.args.length];
        int i = 0;
        for (FuncParam arg : description.args) {
            if (arg.required && !args.containsKey(arg.name))
                throw new Exception("FunctionCache::invoke(): parameter " + arg.name + " is missing in the input");
            else if (!arg.required && !args.containsKey(arg.name)) {
                funcArgs[i] = Converter.toDefaultInput(arg.type);
            } else {
                Object param = args.get(arg.name);
                funcArgs[i] = Converter.toInput(arg.type, param);
            }
            ++i;
        }
        return description.func.invoke(null, funcArgs);
    }

    public String getReturnType(String func) throws Exception {
        FuncDescription description = cache.getIfPresent(func);
        if (description == null)
            throw new Exception(func + " is not a registered API function");
        return description.retType;
    }

    public FuncDescription getDescription(String method) {
        return cache.getIfPresent(method);
    }

    public List<String> listAllAPI() {
        return new ArrayList<>(cache.asMap().keySet());
    }

    public Map<String, Object> getAPIInfo(String method) {
        FuncDescription desc = getDescription(method);
        HashMap<String, Object> ret = new HashMap<>();
        ret.put("method", desc.method);
        ret.put("description", desc.description);
        ret.put("retName", desc.retName);
        ret.put("retType", desc.retType);
        ret.put("retDescription", desc.retDescription);
        ArrayList<Map<String, String>> args = new ArrayList<>();
        for (FuncParam p : desc.args) {
            HashMap<String, String> arg = new HashMap<>();
            arg.put("name", p.name);
            arg.put("type", p.type);
            arg.put("description", p.description);
            args.add(arg);
        }
        // add id input
        // this is completely optional to the user
        // if provided the generated handle will be put into the cache with the user given id
        // otherwise a random id is generated by the server
        if (desc.addIdInput && desc.retType.equals("Handle")) {
            HashMap<String, String> arg = new HashMap<>();
            arg.put("name", "id");
            arg.put("type", "String");
            arg.put("description", "id");
            args.add(arg);
        }
        ret.put("args", args);
        return ret;
    }
}